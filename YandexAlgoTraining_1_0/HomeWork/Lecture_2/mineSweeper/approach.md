# 👀Сканирование соседних ячеек

Представим ячейку и её соседей:
┌────—┬─────┬─────┐
│-1,-1│ -1,0│-1,1 │
├─────┼─────┼─────┤
│ 0,-1│ 0,0 │ 0,1 │ ← центральная ячейка (0,0)
├─────┼─────┼─────┤
│ 1,-1│ 1,0 │ 1,1 │
└─────┴─────┴─────┘

> Массивы направлений:
>
> let di = [1, 1, 1, 0, 0, -1, -1, -1]; // смещения по строкам
>
> let dj = [-1, 0, 1, -1, 1, -1, 0, 1]; // смещения по столбцам

## 🧭Сопоставим индексы массивов с направлениями:

* __k=0__: di[0] = 1, dj[0] = -1 → (1,-1)  = ↙️ влево-вниз
* __k=1__: di[1] = 1, dj[1] = 0 → (1,0)   = ⬇️ вниз
* __k=2__: di[2] = 1, dj[2] = 1 → (1,1)   = ↘️ вправо-вниз
* __k=3__: di[3] = 0, dj[3] = -1 → (0,-1)  = ⬅️ влево
* __k=4__: di[4] = 0, dj[4] = 1 → (0,1)   = ➡️ вправо
* __k=5__: di[5] = -1, dj[5] = -1 → (-1,-1) = ↖️ влево-вверх
* __k=6__: di[6] = -1, dj[6] = 0 → (-1,0)  = ⬆️ вверх
* __k=7__: di[7] = -1, dj[7] = 1 → (-1,1)  = ↗️ вправо-вверх

В коде:

```
for (let k = 0; k < 8; k++) {
// Проверяем соседа по направлению k
    if (field[i + di[k]][j + dj[k]] === '*') {
    counter++;
    }
}
```

> Пример: Если мы в ячейке (3,3) и k=2:
>
> - i + di[2] = 3 + 1 = 4
> - j + dj[2] = 3 + 1 = 4
> - Проверяем ячейку (4,4) = вправо-вниз от (3,3)

# ⊞ Техника "padding" или "рамка безопасности"

field[i] = new Array(M + 2).fill(1);

## 💡Идея

Создаётся поле размером (N+2) x (M+2) вместо N x M. Таким образом
Вокруг основного поля появляется рамка толщиной в одну клетку или M+2 (оба края). В цикле
при этом перебор начинается с индекса 1, что позволяет не выходить за границы поля без дополнительных проверок.

Схематично:

Обычное поле 3x2:     С рамкой 5x4:
┌─┬─┐                   ┌─┬─┬─┬─┐
│ │ │                   │1│1│1│1│ ← рамка
├─┼─┤                   ├─┼─┼─┼─┤
│ │ │                   │1│ │ │1│
├─┼─┤                   ├─┼─┼─┼─┤
│ │ │                   │1│ │ │1│
└─┴─┘                   ├─┼─┼─┼─┤
                        │1│ │ │1│
                        ├─┼─┼─┼─┤
                        │1│1│1│1│ ← рамка
                        └─┴─┴─┴─┘

## 👍Преимущества этой техники:

- ✅ Нет проверок границ — можем смело обращаться к field[i±1][j±1]
- ✅ Чистый код — фокус на основной логике, а не на edge cases
- ✅ Производительность — меньше условных операторов
