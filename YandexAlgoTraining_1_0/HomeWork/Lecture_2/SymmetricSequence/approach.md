# Идея с последовательным добавлением элементов в конец массива

1. Итерируемся по массиву и на каждой итерации создаём копию исходного массива
```
for (let addCount = 0; addCount <= arr.length; addCount++) {
    let newArr = [...arr];
    ....
    }
```
2. В эту копию пушим первые addCount элементов в обратном порядке
```
for (let i = addCount - 1; i >= 0; i--) {
            newArr.push(arr[i]);
        }
```
3. Проверяем, что новый массив не является палиндромом
```
    if (isPalindrome(newArr)) {
            if (addCount === 0) {
                return 0;
            } else {
                let toAdd = [];
                for (let i = addCount - 1; i >= 0; i--) {
                    toAdd.push(arr[i]);
                }
                return `${addCount}\n${toAdd.join(' ')}`;
            }
        }
```
⚠️Здесь важно выполнить проверку `addCount === 0`, так как если начальный массив является палиндромом, то нужно выходить. 
В противном случае создаём массив для добавления всех элементов, с помощью которых создаём симметрию.

## Сложность

Сложность решения — O(n²):    

- Внешний цикл: до n итераций (пробуем добавить 0,1,2...n элементов)
- Для каждой итерации: проверка палиндрома O(n)
- Итого: O(n²)

Однако поскольку ограничения относительно небольшие (количество элементов исходной последовательности (1<= N <= 100), то данное решение проходит тесты.

## Оптимизации

Возникла идея не создавать копию массива на каждой итерации, а создать одну и на каждой итерации добавлять нужный элемент.
Но есть проблема:

мы добавляем элементы по одному за итерацию, а нужный нам "обратный порядок" — это обратный порядок первых addCount элементов.

Имеем:
- addCount=1: добавляем arr[0]
- addCount=2: добавляем arr[1] (не arr[0] заново!)
- addCount=3: добавляем arr[2]

Нужно:
- addCount=1: [...arr, arr[0]]
- addCount=2: [...arr, arr[1], arr[0]] ← вот тут проблема!
- addCount=3: [...arr, arr[2], arr[1], arr[0]]

То есть, в инкрементальном подходе мы не можем вставить arr[0] между уже добавленными элементами.
