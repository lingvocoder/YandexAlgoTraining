const fs = require('fs');
const fileContent = fs.readFileSync("input.txt", "utf8");
const [K1, M, K2, P2, N2] = fileContent.toString().trim().split(" ").map(v => Number(v));
const result = calcFloor(K1, M, K2, P2, N2);
fs.writeFileSync("output.txt", result.toString());


function calcFloor(K1, M, K2, P2, N2) {
    let P1;
    let N1;
    let k = Math.round(K2 / (N2 + (M * (P2 - 1)))); //кол-во квартир на этаж
    let kP = M * k;//кол-во квартир на подъезд
    P1 = Math.round(K1 / kP / 2) < 1 ? P2 : P2 + Math.round(K1 / kP / 2);
    // N1 = Math.abs(K1 - kP) % k > 0 ? Math.floor(Math.abs(K1 - kP) / k) + 1 : N2;

    if (P2 === 1 && N1 === 1) return 0;
    // return `${P1} ${N1}`;
    return `${P1}`;
}















//Какой же **  головная боль ваша задача про скорую помощь.
//
// Дальше оба решения на с++ будет и мои мысли по этому поводу.
//
// Немного лирики: Я вообще не планировал её решать, просто повторял алгоритмы и смотрел плейлист с лекциями на 2х, заглянул в задачи и как будто там всё достаточно просто было, но на разборе решил сам попробовать решить задачу с которой меньше всего народу справилось...
//
// Сначала я даже не подумал, что её можно перебором решать и сразу над аналитическим решением начал корпеть. И как оказалось, я его даже написал, но в одном из условий перепутал n2 с p2 в сравнении с m и мой мозг просто отказывался это замечать.
//
// Ладно, вспомнил, что на лекции проходили стресс тесты, написал прямое решение, но и оно подало на более поздних тестах.
//
// В отчаянии я пришел в комменты и просто адаптировал местное питоновское решение под плюсы и оно заработало, черт побери. С его помощью оттестировал свой перебор и оказалось, что во-первых, я забыл добавить проверку (n2 > m) которую таки подразумевал в первом своем решении, а во-вторых... ПЕРЕПОЛНЕНИЕ ЧЕРТОВОГО ИНТА! Казалось бы, вы должны спросить меня, а почему же в твоей адаптации с питоновского решения переполнения не происходило? А ОНО ПРОИСХОДИЛО! Просто там ключевые условия и структура программы не позволили ей сломаться.
//
// Рассмотрим теперь подробнее задачу и в конце я добавлю все три варианта кода.
//
// Прежде всего надо понять главную формулу подсчета номера квартиры:
//
// K = ((P - 1) * M + (N - 1)) * x + 1 + C, где (0 <= C < x)
//
// Здесь К - номер квартиры; Р - номер подъезда; М - этажность здания; N - номер этажа; х - наша главная переменная - количество квартир на этаже; и С - это некая константа которая может принимать значения от нуля включительно, до х не включительно.
//
// Смысл формулы: посчитать количество лестничных пролетов ДО нашего этажа (число подъездов без нашего умноженное на этажность плюс число этажей без нашего), умножить это число на количество квартир на этаже, прибавить единицу так как нумерация квартир начинается с единицы, и прибавить некую константу С, которая определяет в какой именно квартире на нашем этаже мы находимся.
//
// Тут возникает вопрос, почему бы не объединить 1 + С в одну константу? А всё дело в том, что мы хотим дальше считать как левую так и правую части этой формулы с помощью целочисленного деления на х, а именно яростно использовать школьную формулу деления с остатком. Перенесем эту единичку к номеру квартиры, чтобы получить искомый вид:
//
// K - 1 = ((P - 1) * M + (N - 1)) * x + C, где (0 <= C < x)
//
// Из этой формулы можем получить формулы для P и N, но сначала введем обозначения :
//
// // - целочисленное деление; % остаток от деления
//
// То есть применительно к нашей формуле:
//
// (K - 1) // x = ((P - 1) * M + (N - 1))
//
// (K - 1) % x = C
//
// Заметим так же, что в силу того, что этаж не может быть больше этажности:
//
// ((P - 1) * M + (N - 1)) // М = (P - 1)
//
// ((P - 1) * M + (N - 1)) % М = (N - 1)
//
// Отсюда, подставляя (K - 1) // x = ((P - 1) * M + (N - 1)):
//
// P = 1 +  ((K - 1) // x) // М
//
// N = 1 +  ((K - 1) // x) % М
//
// На данном этапе вы уже готовы писать решение перебором.